# __<center>TASK_ALLOCATION_WITH_Q_LEARNING_AND_KNN</center>__
## **Description**
使用knn和Qlearning的方法相结合来处理平台调度任务顺序的问题。

三个平台，N个任务，N个任务寻找合适的平台进行计算，在每一个平台完成任务有不同的方法，有不同的总成本。目的是最小化三个平台的总和成本。
## **1. 代码文件和数据文件的介绍** 

+ ## 代码介绍：
  
  代码文件有select_knn.py, Solution.py和test.py。
  
  其中select_knn.py是将任务通过KNN算法进行分类的代码，而Solution.py是总算法的运行代码。
 
+ ## 数据介绍：
  
  train_set.txt是作为KNN分类的样本数据，数据表示不同类型任务的平台分类标签。

## __2. 环境及其Python模块的要求__

+ ## 代码运行环境介绍：
  
  + OS：Windows 10
  + IDE：PyCharm
  + CPU or GPU

## **3. 代码逻辑结构**
+ ### 客户需求模型能跑出5个结果进行对比，因此算法包括每个任务的cost的绘图运行了5次。
  
+ ### 先随机生成n个任务，该任务其实是通过外部设备不同的参数来描述的，具体任务描述如下：
     + Bn表示计算Rn所需的输入数据的大小（单位比特），取值：（10,100）
     + Dn表示完成计算任务Rn每比特所需的CPU周期总数，取值：（0.01,0.1）
     + t表示任务Rn的最大可容忍时间，取值：（0.1-10）
     + 3 个平台 1，2，3，定义为（time，size，f）
     + Time是任务在该平台计算的最小时间，定义为0.1， 0.5 ，1
     + Size是平台共有的CPU周期数5 30 100
     + F是平台的计算能力，2， 5， 20

+ ### 将随机生成的任务通过KNN算法进行分类，将所有任务都按照距离分成三类。
+ ### 平台1、3：根据不同平台的不同cost计算公式和约束条件来计算，特别的任务超过平台1的约束条件就将任务加入到平台2。
+ ### 平台2由于内部复杂，需要调整任务调度的顺序来最优化效率，抽象得到最终是调整调度的顺序最优化参数a和参数b。
+ ### 因此使用强化学习Q-learning通过和自定义的reward下的环境进行交互得到最适合的任务调度顺序。
+ ### 详细算法需求如实现.docx和实现v0.1.docx所示，具体代码实现如Solution.py所示。
  

## **4. 运行代码及其参数结果的保存方法**

+ ## 运行
  + 在Pycharm中运行Solution.py运行算法。
  + 在命令行的当前目录下，运行 python Solution 运行代码。

## __5. 模型结果__
+ ## 模型结果介绍
    PS：客户通过KNN的验证集的测试，得到F1结果为87%。
  + ### __F1结果__：F1=2*(准确率*召回率)/(准确率+召回率)
    + ### F1的值是精准率与召回率的调和平均数。F1的取值范围从0到1的数量越大，表明实现越理想。

    + ### Precision（精准率）=TP/(TP+FP)

    + ### Recall（召回率）= TP/(TP+FN)
    
    